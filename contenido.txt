./analysis/intensity.py:
import numpy as np
import pandas as pd
from skimage import measure
from tqdm import tqdm

from multiplex_pipeline.config          import ROI_PATTERN, DAPI_CONNECTIVITY, PIXEL_AREA
from multiplex_pipeline.utils.validation import verify_binary

def extract_roi_key(img_name):
    m = ROI_PATTERN.search(img_name)
    return m.group(1).lower() if m else None

def label_dapi(mask):
    """Si la máscara es binaria, la etiqueta; si no, la devuelve."""
    if len(np.unique(mask)) <= 2:
        return measure.label(mask, connectivity=DAPI_CONNECTIVITY)
    return mask

def get_labels_and_counts(labeled_mask):
    flat = labeled_mask.ravel()
    counts = np.bincount(flat)
    labels = np.arange(len(counts))
    valid = (labels != 0) & (counts > 0)
    return labels[valid], counts[valid], flat

def get_centroids_map(labeled_mask):
    return {p.label: p.centroid for p in measure.regionprops(labeled_mask)}

def compute_mean_intensities(mask_flat, img_channel, valid, counts):
    sums = np.bincount(mask_flat, weights=img_channel.ravel())
    return sums[valid] / counts

def compute_binary_flags(valid_labels, mask_flat, mask):
    verify_binary(mask, "mask")
    flat = mask.ravel()
    positive = np.unique(mask_flat[flat > 0])
    return np.isin(valid_labels, positive).astype(int)

def process_roi(
    img_name,
    img_data,
    dapi_masks,
    ck_masks,
    ngfr_masks,
    channels,
    marker_dict,
    pixel_area_um2=PIXEL_AREA
):
    roi = extract_roi_key(img_name)
    if roi is None:
        print(f"ROI no encontrada en '{img_name}'"); return None

    dapi_key = f"{roi}_dapi"
    if dapi_key not in dapi_masks:
        print(f"{dapi_key} no existe en dapi_masks"); return None

    mask_dapi = dapi_masks[dapi_key]
    if mask_dapi.shape != img_data.shape[1:]:
        print(f"Dimensiones no coinciden para {img_name}"); return None

    lbl = label_dapi(mask_dapi)
    valid_labels, counts, flat = get_labels_and_counts(lbl)
    cent_map = get_centroids_map(lbl)

    # DataFrame base
    df = pd.DataFrame({
        "ROI":           roi,
        "DAPI_ID":       valid_labels,
        "Area_pixels":   counts,
        "Area_um2":      counts * pixel_area_um2,
        "centroid_y":    [cent_map.get(l, (np.nan,))[0] for l in valid_labels],
        "centroid_x":    [cent_map.get(l, (np.nan,))[1] for l in valid_labels],
    })

    # Intensidades y flags
    for ch in tqdm(channels, desc=f"Canales {roi}", unit="ch"):
        name = marker_dict.get(ch, f"Ch{ch}")
        col_base = name.replace(" ", "_").replace("-", "_").replace(">", "").replace("<", "")
        img_ch = img_data[ch]

        if "ngfr" in name.lower():
            df[f"mean_intensity_{col_base}"] = compute_mean_intensities(flat, img_ch, valid_labels, counts)
            mask_ng = ngfr_masks.get(roi, np.zeros_like(mask_dapi))
            df[f"is_positive_{col_base}"] = compute_binary_flags(valid_labels, flat, mask_ng)

        elif "ck" in name.lower():
            mask_ck = ck_masks.get(roi, np.zeros_like(mask_dapi))
            df[f"is_positive_{col_base}"] = compute_binary_flags(valid_labels, flat, mask_ck)

        else:
            df[f"mean_intensity_{col_base}"] = compute_mean_intensities(flat, img_ch, valid_labels, counts)

    return df

def intensity_to_binary(df, thresholds, exclude=None):
    exclude = exclude or ['ROI','DAPI_ID','Area_pixels','Area_um2','centroid_x','centroid_y']
    markers = [c for c in df if c not in exclude]
    means = df.groupby('ROI')[markers].mean()
    stds  = df.groupby('ROI')[markers].std()
    dfb   = df.join(means,   on='ROI', rsuffix='_mean') \
              .join(stds,    on='ROI', rsuffix='_std')

    for m in markers:
        note = thresholds.get(m, 0.0)
        dfb[f"{m}_threshold"] = dfb[f"{m}_mean"] + note * dfb[f"{m}_std"]
        dfb[f"{m}_binary"]    = (dfb[m] > dfb[f"{m}_threshold"]).astype(int)

    cols = ['ROI','DAPI_ID','Area_pixels','Area_um2','centroid_x','centroid_y'] \
         + [f"{m}_binary" for m in markers]
    return dfb[cols]
--------
./analysis/positivity.py:
--------
./analysis/spatial.py:
import os
import numpy as np
import pandas as pd
from scipy.spatial import cKDTree
from skimage.measure import regionprops
from multiplex_pipeline.config import PIXEL_SIZE, PIXEL_AREA

def compute_mask_area_summary(ck_masks, ngfr_masks, pixel_area=PIXEL_AREA):
    """
    Computes the area summary for each ROI based on CK and NGFR masks.

    Returns:
        pd.DataFrame: columns ['ROI', 'CK_Positive_Area_um2', 'CK_NGFR_Positive_Area_um2', 'total_area_roi_um2']
    """
    data = []
    for roi in ck_masks:
        ck_mask = ck_masks.get(roi)
        ngfr_mask = ngfr_masks.get(roi)
        if ck_mask is None or ngfr_mask is None or ck_mask.shape != ngfr_mask.shape:
            continue
        area_ck = np.sum(ck_mask == 1) * pixel_area
        area_ckng = np.sum((ck_mask == 1) & (ngfr_mask == 1)) * pixel_area
        total = ck_mask.size * pixel_area
        data.append({
            'ROI': roi,
            'CK_Positive_Area_um2': area_ck,
            'CK_NGFR_Positive_Area_um2': area_ckng,
            'total_area_roi_um2': total
        })
    return pd.DataFrame(data)


def compute_subpop_cells_per_area(
    df_binary,
    subpop_conditions,
    cond_map,            # antes: condition_column_map
    mask_summary,        # antes: mask_area_summary
    rois,                # antes: selected_rois
    out_dir,             # antes: path_save
    roi_col='ROI'
):
    """
    Retorna:
      summary_df, summary_formatted

    Parámetros renombrados para coincidir con tu llamada en el notebook:
      cond_map      → mapping condiciones → columnas binarias
      mask_summary  → DataFrame con áreas por ROI
      rois          → lista de ROIs a procesar
      out_dir       → carpeta donde se guardan los CSV formateados
    """
    import os
    import pandas as pd
    # 1) Parsear condiciones
    parsed = {}
    for cond in subpop_conditions:
        val = 1 if cond.strip().endswith('+') else 0
        key = cond.strip()[:-1].strip()
        col = cond_map.get(key)
        if col:
            parsed[col] = val
        else:
            print(f"Warning: No mapping para '{cond}' → ignorando.")

    # 2) Lookup de áreas
    area_lookup = mask_summary.set_index('ROI')

    # 3) Filtrar solo ROIs
    df_filt = df_binary[df_binary[roi_col].isin(rois)]
    missing = set(rois) - set(df_filt[roi_col].unique())
    if missing:
        print(f"Warning: ROIs en 'rois' no halladas en df_binary: {missing}")

    # 4) Iterar por ROI
    results = []
    for roi in rois:
        grp = df_filt[df_filt[roi_col] == roi]
        if grp.empty or roi not in area_lookup.index:
            continue

        # filtrar subpoblación
        mask_sub = pd.Series(True, index=grp.index)
        for col, val in parsed.items():
            mask_sub &= (grp[col] == val)
        cnt = mask_sub.sum()

        # áreas
        area_ck   = area_lookup.at[roi, 'CK_Positive_Area_um2']
        area_ckng = area_lookup.at[roi, 'CK_NGFR_Positive_Area_um2']

        # densidades
        dens_ck   = cnt/area_ck   if area_ck>0   else 0
        dens_ckng = cnt/area_ckng if area_ckng>0 else 0

        results.append({
            'ROI': roi,
            'Subpopulation_Cell_Count': cnt,
            'CK_Positive_Area_um2': area_ck,
            'CK_NGFR_Positive_Area_um2': area_ckng,
            'Cells_per_um2_CK_Positive': dens_ck,
            'Cells_per_um2_CK_NGFR_Positive': dens_ckng
        })

    # 5) DataFrames de salida
    summary_df = pd.DataFrame(results)

    # 6) Formatear para guardado
    summary_fmt = summary_df.copy()
    summary_fmt['Cells_per_um2_CK_Positive']   = summary_fmt['Cells_per_um2_CK_Positive'].map(lambda x: f"{x:.6f}")
    summary_fmt['Cells_per_um2_CK_NGFR_Positive'] = summary_fmt['Cells_per_um2_CK_NGFR_Positive'].map(lambda x: f"{x:.6f}")
    summary_fmt['CK_Positive_Area_um2']   = summary_fmt['CK_Positive_Area_um2'].map(lambda x: f"{x:.2f}")
    summary_fmt['CK_NGFR_Positive_Area_um2'] = summary_fmt['CK_NGFR_Positive_Area_um2'].map(lambda x: f"{x:.2f}")

    # Renombrar columnas con etiqueta dinámica
    label = "_".join([c.replace("+","Pos").replace(" ", "") for c in subpop_conditions])
    summary_fmt.rename(columns={
        'Subpopulation_Cell_Count': f"Subpopulation Cell Count ({', '.join(subpop_conditions)})",
        'CK_Positive_Area_um2':     'CK⁺ Area (µm²)',
        'CK_NGFR_Positive_Area_um2':'CK⁺NGFR⁺ Area (µm²)',
        'Cells_per_um2_CK_Positive':'Cells per µm² (CK⁺)',
        'Cells_per_um2_CK_NGFR_Positive':'Cells per µm² (CK⁺NGFR⁺)'
    }, inplace=True)

    # Guardar CSV
    os.makedirs(out_dir, exist_ok=True)
    csv_path = os.path.join(out_dir, f"cell_density_area_{label}.csv")
    summary_fmt.to_csv(csv_path, index=False)
    print(f"Saved: {csv_path}")

    return summary_df, summary_fmt



def compute_distances(sub_df, mask, bin_col):
    """
    For each cell in sub_df (with centroid_row/col), returns two lists:
       distances to mask positive and negative regions (µm).
    """
    pos = np.column_stack(np.where(mask == 1))
    neg = np.column_stack(np.where(mask == 0))
    tree_p = cKDTree(pos) if len(pos) else None
    tree_n = cKDTree(neg) if len(neg) else None
    d_to_pos, d_to_neg = [], []
    for _, r in sub_df.iterrows():
        cent = (r['centroid_row'], r['centroid_col'])
        if r.get(bin_col, 0) == 1:
            d_to_pos.append(0.0)
            d_to_neg.append(tree_n.query(cent)[0] * PIXEL_SIZE if tree_n else 0.0)
        else:
            d_to_pos.append(tree_p.query(cent)[0] * PIXEL_SIZE if tree_p else 0.0)
            d_to_neg.append(0.0)
    return d_to_pos, d_to_neg


def get_centroids(dapi_mask):
    """
    Extracts centroids from a labeled DAPI mask.
    Returns DataFrame with columns ['DAPI_ID','centroid_row','centroid_col']
    """
    data = []
    for p in regionprops(dapi_mask):
        r, c = p.centroid
        data.append({'DAPI_ID': p.label, 'centroid_row': int(r), 'centroid_col': int(c)})
    return pd.DataFrame(data)


def compute_subpop_distances(subpopA_df, subpopB_df):
    """
    Computes pairwise distances (pixels) between subpop A and B centroids.
    Returns DataFrame with columns [B_cell_id,B_row,B_col,A_cell_id,A_row,A_col,distance_px].
    """
    if subpopA_df.empty or subpopB_df.empty:
        return pd.DataFrame()
    A = subpopA_df.assign(key=1)
    B = subpopB_df.assign(key=1)
    df = pd.merge(B, A, on='key', suffixes=('_b','_a')).drop('key', axis=1)
    df['distance_px'] = np.sqrt((df['centroid_row_b']-df['centroid_row_a'])**2 + (df['centroid_col_b']-df['centroid_col_a'])**2)
    return df.rename(columns={
        'DAPI_ID_b': 'B_cell_id', 'centroid_row_b': 'B_row', 'centroid_col_b': 'B_col',
        'DAPI_ID_a': 'A_cell_id', 'centroid_row_a': 'A_row','centroid_col_a': 'A_col'
    })
--------
./analysis/subpopulations.py:
--------
./analysis/__init__.py:
--------
./config.py:
# config.py
import os
import re
from pathlib import Path
from multiplex_pipeline.preprocessing.segmentation import post_process_mask, post_process_mask_closing

# User information
CNIO_USER = "jgagullo"

# Server base paths
BASE_SERVER_PATH = Path(r"\\imgserver.cnio.es\IMAGES\CONFOCAL\IA\Projects\2024\2024_10_21_jgagullo\spatial analisis\qpath")
DATA_FOLDER = BASE_SERVER_PATH / "data" / CNIO_USER
EXPORT_DAPI_FOLDER = BASE_SERVER_PATH / "qpathprojects" / CNIO_USER / "export_DAPI"
EXPORTED_MASKS_FOLDER = BASE_SERVER_PATH / "qpathprojects" / CNIO_USER / "exportedmasks"

# File patterns
IMAGE_EXTENSIONS = [".ome.tiff", ".tiff", ".tif"]
DAPI_PATTERN = re.compile(r"roi(\d+)_dapi", re.IGNORECASE)
CSV_EXTENSION = ".csv"

# Results directories (padre, sin usuario)
RESULTS_BASE_DIR         = Path(".") / "results_spatial_analysis"
CELL_COUNT_OUTPUT_DIR    = RESULTS_BASE_DIR / CNIO_USER / "cell_counting"
CELL_DENSITY_OUTPUT_DIR  = RESULTS_BASE_DIR / CNIO_USER / "cell_density_area"
BOXPLOTS_DISTANCES_DIR   = RESULTS_BASE_DIR / CNIO_USER / "boxplots_distances_to_mask"
BOXPLOTS_DISTANCES_HEATMAPS_DIR   = RESULTS_BASE_DIR / CNIO_USER / "boxplots_distances_between_populations"
DISTANCES_SUBPOP_DIR     = RESULTS_BASE_DIR / CNIO_USER / "distances_between_mask_and_subpopulation"
DISTANCES_POPULATIONS_DIR= RESULTS_BASE_DIR / CNIO_USER / "distances_between_populations"

# Imaging constants
PIXEL_SIZE       = 0.17  # micrometers
PIXEL_AREA       = PIXEL_SIZE ** 2  # µm²
MASK_ALPHA       = 0.5
DEFAULT_BRIGHTNESS = 10

# Channels and markers
CHANNELS_OF_INTEREST = [10, 13, 7, 17, 1, 0, 15, 5, 20, 21, 9, 19, 3]
MARKER_LABELS = {
    0: "FOXP3",
    1: "IFN-gamma",
    2: "CD20 - cyto",
    3: "HLA-DR",
    4: "CD279",
    5: "CD4",
    6: "A_Podoplan",
    7: "Ki67",
    8: "CD163",
    9: "CD11b",
    10: "Pan-Cytokeratin CK",
    11: "A_Actin",
    12: "CD31",
    13: "NGFR",
    14: "DAPI",
    15: "CD3",
    16: "CD56",
    17: "CD274",
    18: "CD45",
    19: "CD11c",
    20: "CD8a",
    21: "CD68",
}

# Mask creation settings
CK_SETTINGS = {
    "channel_index": 10,
    "user_scores": -1,
    "scaling_divisor": 10,
    "base_folder_path": EXPORTED_MASKS_FOLDER,
    "min_size": 2000,
    "max_hole_size": 10000,
    "mask_label": "CK",
    "mask_filename": "CK_mask_binary.tif",
    "post_process_funcs": [post_process_mask],
    "brightness_factor": None,
    "require_dapi": False,
}
NGFR_SETTINGS = {
    "channel_index": 13,
    "user_scores": {
        'ROI1.ome.tiff': 2.7, 'ROI2.ome.tiff': 2.7, 'ROI3.ome.tiff': 2.7,
        'ROI4.ome.tiff': 1.8, 'ROI5.ome.tiff': 1.8, 'ROI6.ome.tiff': 1.8,
        'ROI7.ome.tiff': 1.5, 'ROI8.ome.tiff': 1.2,'ROI9.ome.tiff': 1.2, 'ROI10.ome.tiff': 2.7,
        'ROI11.ome.tiff': 2.4, 'ROI12.ome.tiff': 2.7, 'ROI13.ome.tiff': 2.1,
    },
    "scaling_divisor": 3,
    "base_folder_path": EXPORTED_MASKS_FOLDER,
    "min_size": 200,
    "max_hole_size": 75000,
    "mask_label": "NGFR",
    "mask_filename": "NGFR_mask_binary.tif",
    "post_process_funcs": [post_process_mask_closing, post_process_mask],
    "brightness_factor": 25,
    "require_dapi": True,
}

# Intensity thresholds
INTENSITY_THRESHOLDS = {
    'is_positive_Pan_Cytokeratin_CK': 0,
    'mean_intensity_NGFR': 0.25,
    'is_positive_NGFR': 0,
    'mean_intensity_Ki67': 0,
    'mean_intensity_CD274': 2.5,
    'mean_intensity_IFN_gamma': 1.5,
    'mean_intensity_FOXP3': 2.25,
    'mean_intensity_CD3': 1.25,
    'mean_intensity_CD4': 1,
    'mean_intensity_CD8a': 2.5,
    'mean_intensity_CD68': 2,
    'mean_intensity_CD11b': 2,
    'mean_intensity_CD11c': 2,
    'mean_intensity_HLA_DR': 1.5,
}


CARACTERIZATION_COMBINATIONS = {
    'Tumor': lambda df: df['is_positive_Pan_Cytokeratin_CK_binary'] == 1,
    'Tumor NGFR+': lambda df: (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) & (df['mean_intensity_NGFR_binary'] == 1),
    'Tumor NGFR-': lambda df: (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) & (df['mean_intensity_NGFR_binary'] == 0),
    'Tumor NGFR+ Ki67+': lambda df: (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) & (df['mean_intensity_NGFR_binary'] == 1) & (df['mean_intensity_Ki67_binary'] == 1),
    'Tumor NGFR- Ki67+': lambda df: (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) & (df['mean_intensity_NGFR_binary'] == 0) & (df['mean_intensity_Ki67_binary'] == 1),
    'Tumor NGFR+ CD274+': lambda df: (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) & (df['mean_intensity_NGFR_binary'] == 1) & (df['mean_intensity_CD274_binary'] == 1),
    'Tumor NGFR- CD274+': lambda df: (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) & (df['mean_intensity_NGFR_binary'] == 0) & (df['mean_intensity_CD274_binary'] == 1),
    'Tumor NGFR+ IFN+': lambda df: (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) & (df['mean_intensity_NGFR_binary'] == 1) & (df['mean_intensity_IFN_gamma_binary'] == 1),
    'Tumor NGFR- IFN+': lambda df: (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) & (df['mean_intensity_NGFR_binary'] == 0) & (df['mean_intensity_IFN_gamma_binary'] == 1),
    'Tumor NGFR+ HLA_DR+': lambda df: (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) & (df['mean_intensity_NGFR_binary'] == 0) & (df['mean_intensity_HLA_DR_binary'] == 1),
    'Tumor NGFR- HLA_DR+': lambda df: (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) & (df['mean_intensity_NGFR_binary'] == 0) & (df['mean_intensity_HLA_DR_binary'] == 1),
    
  
}


# Combinations for tumor infiltration
INFILTRATION_COMBINATIONS = {
    'Tumor CD3+ CD4+ FOXP3+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['mean_intensity_CD3_binary'] == 1) &
        (df['mean_intensity_CD4_binary'] == 1) &
        (df['mean_intensity_FOXP3_binary'] == 1)
    ),
    'Stroma CD3+ CD4+ FOXP3+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 0) &
        (df['mean_intensity_CD3_binary'] == 1) &
        (df['mean_intensity_CD4_binary'] == 1) &
        (df['mean_intensity_FOXP3_binary'] == 1)
    ),
    'Tumor CD3+ CD8+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['mean_intensity_CD3_binary'] == 1) &
        (df['mean_intensity_CD8a_binary'] == 1)
    ),
    'Stroma CD3+ CD8+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 0) &
        (df['mean_intensity_CD3_binary'] == 1) &
        (df['mean_intensity_CD8a_binary'] == 1)
    ),
    'Tumor CD68+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['mean_intensity_CD68_binary'] == 1)
    ),
    'Stroma CD68+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 0) &
        (df['mean_intensity_CD68_binary'] == 1)
    ),
    'Tumor CD11b+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['mean_intensity_CD11b_binary'] == 1)
    ),
    'Stroma CD11b+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 0) &
        (df['mean_intensity_CD11b_binary'] == 1)
    ),
    'Tumor CD11c+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['mean_intensity_CD11c_binary'] == 1)
    ),
    'Stroma CD11c+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 0) &
        (df['mean_intensity_CD11c_binary'] == 1)
    ),
    'Tumor MHCII+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['mean_intensity_HLA_DR_binary'] == 1)
    ),
    'Stroma MHCII+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 0) &
        (df['mean_intensity_HLA_DR_binary'] == 1)
    ),
}

# Combinations for NGFR-related infiltration
NGFR_INFILTRATION_COMBINATIONS = {
    'Tumor NGFR+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 1)
    ),
    'Tumor NGFR-': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 0)
    ),
    'Tumor NGFR+ CD3+ CD4+ FOXP3+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 1) &
        (df['mean_intensity_CD3_binary'] == 1) &
        (df['mean_intensity_CD4_binary'] == 1) &
        (df['mean_intensity_FOXP3_binary'] == 1)
    ),
    'Tumor NGFR- CD3+ CD4+ FOXP3+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 0) &
        (df['mean_intensity_CD3_binary'] == 1) &
        (df['mean_intensity_CD4_binary'] == 1) &
        (df['mean_intensity_FOXP3_binary'] == 1)
    ),
    'Tumor NGFR+ CD3+ CD8+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 1) &
        (df['mean_intensity_CD3_binary'] == 1) &
        (df['mean_intensity_CD8a_binary'] == 1)
    ),
    'Tumor NGFR- CD3+ CD8+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 0) &
        (df['mean_intensity_CD3_binary'] == 1) &
        (df['mean_intensity_CD8a_binary'] == 1)
    ),
    'Tumor NGFR+ CD3+ CD8+ IFN+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 1) &
        (df['mean_intensity_CD3_binary'] == 1) &
        (df['mean_intensity_CD8a_binary'] == 1) &
        (df['mean_intensity_IFN_gamma_binary'] == 1)
    ),
    'Tumor NGFR- CD3+ CD8+ IFN+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 0) &
        (df['mean_intensity_CD3_binary'] == 1) &
        (df['mean_intensity_CD8a_binary'] == 1) &
        (df['mean_intensity_IFN_gamma_binary'] == 1)
    ),
    'Tumor NGFR+ CD68+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 1) &
        (df['mean_intensity_CD68_binary'] == 1)
    ),
    'Tumor NGFR- CD68+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 0) &
        (df['mean_intensity_CD68_binary'] == 1)
    ),
    'Tumor NGFR+ CD11b+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 1) &
        (df['mean_intensity_CD11b_binary'] == 1)
    ),
    'Tumor NGFR- CD11b+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 0) &
        (df['mean_intensity_CD11b_binary'] == 1)
    ),
    'Tumor NGFR+ CD11c+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 1) &
        (df['mean_intensity_CD11c_binary'] == 1)
    ),
    'Tumor NGFR- CD11c+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 0) &
        (df['mean_intensity_CD11c_binary'] == 1)
    ),
    'Tumor NGFR+ MHCII+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 1) &
        (df['mean_intensity_HLA_DR_binary'] == 1)
    ),
    'Tumor NGFR- MHCII+': lambda df: (
        (df['is_positive_Pan_Cytokeratin_CK_binary'] == 1) &
        (df['is_positive_NGFR_binary'] == 0) &
        (df['mean_intensity_HLA_DR_binary'] == 1)
    ),
}

# Condition column mapping
CONDITION_COLUMN_MAP = {
    'FOXP3_intensity': 'mean_intensity_FOXP3_binary',
    'IFN-gamma_intensity': 'mean_intensity_IFN_gamma_binary',
    'HLA-DR_intensity': 'mean_intensity_HLA_DR_binary',
    'CD4_intensity': 'mean_intensity_CD4_binary',
    'Ki67_intensity': 'mean_intensity_Ki67_binary',
    'CD163_intensity': 'mean_intensity_CD163_binary',
    'CD11b_intensity': 'mean_intensity_CD11b_binary',
    'CD3_intensity': 'mean_intensity_CD3_binary',
    'CD274_intensity': 'mean_intensity_CD274_binary',
    'CD11c_intensity': 'mean_intensity_CD11c_binary',
    'CD8a_intensity': 'mean_intensity_CD8a_binary',
    'CD68_intensity': 'mean_intensity_CD68_binary',
    'CK_mask': 'is_positive_Pan_Cytokeratin_CK_binary',
    'NGFR_mask': 'is_positive_NGFR_binary',
    'NGFR_intensity': 'mean_intensity_NGFR_binary',
}

# Subpopulation definitions
SUBPOPULATIONS = {
    "Tregs": ["CD3_intensity+", "CD4_intensity+", "FOXP3_intensity+"],
    "T CD8+": ["CD3_intensity+", "CD8a_intensity+"],
    "T CD8+ Activator": ["CD3_intensity+", "CD8a_intensity+", "IFN-gamma_intensity+"],
    "Macrophages CD68+": ["CD68_intensity+"],
    "DC CD11b+": ["CD11b_intensity+"],
    "DC CD11c+": ["CD11c_intensity+"],
    "DC HLA-DR+": ["HLA-DR_intensity+"],
}

# Conditions for two-population distances (A group)
SUBPOPULATION_A_POSITIVE = ["CK_mask+", "NGFR_intensity+"]
SUBPOPULATION_A_NEGATIVE = ["CK_mask+", "NGFR_intensity-"]

# CK-only subpopulations for two-population distances
CK_SUBPOPULATIONS = {
    "CK+ Tregs": ["CK_mask+", "CD3_intensity+", "CD4_intensity+", "FOXP3_intensity+"],
    "CK+ T CD8+": ["CK_mask+", "CD3_intensity+", "CD8a_intensity+"],
    "T CD8+ Activator": ["CD3_intensity+", "CD8a_intensity+", "IFN-gamma_intensity+"],
    "CK+ Macrophages": ["CK_mask+", "CD68_intensity+"],
    "CK+ DC CD11b+": ["CK_mask+", "CD11b_intensity+"],
    "CK+ DC CD11c+": ["CK_mask+", "CD11c_intensity+"],
    "CK+ DC HLA-DR+": ["CK_mask+", "HLA-DR_intensity+"],
}

# Shading colors for heatmaps
SHADING_COLORS = {
    "CK_mask": (1.0, 0.0, 0.0),  # red
    "NGFR_mask": (1.0, 0.0, 1.0),  # magenta
}

# ROIs to analyze
ROIS_TO_ANALYZE = ["roi1"]


 #process_roi
import re
ROI_PATTERN       = re.compile(r"(ROI\d+)", re.IGNORECASE)
DAPI_CONNECTIVITY = 1--------
./io/loaders.py:
from pathlib import Path
from typing import Dict
import pandas as pd
import numpy as np
from tifffile import imread
import imageio.v2 as imageio
from tqdm import tqdm

from multiplex_pipeline.config import (
    DATA_FOLDER,
    EXPORT_DAPI_FOLDER,
    IMAGE_EXTENSIONS,
    DAPI_PATTERN,
    CSV_EXTENSION,
)


def load_ome_tif_images(
    data_folder: Path = DATA_FOLDER,
    show_progress: bool = True
) -> Dict[str, np.ndarray]:
    """
    Loads all OME-TIFF images from the specified folder.
    Returns a dict mapping filename -> image array (C, H, W).

    Parameters:
        data_folder: Path to search for images.
        show_progress: If True, displays a progress bar during loading.
    """
    images: Dict[str, np.ndarray] = {}
    base = Path(data_folder)

    # Normalizar extensiones a minúsculas
    exts = {e.lower() for e in IMAGE_EXTENSIONS}

    # Recolectar todos los ficheros cuya concatenación de sufijos coincida con alguna extensión
    candidates = [
        p for p in base.iterdir()
        if p.is_file() and ''.join(p.suffixes).lower() in exts
    ]

    iterator = tqdm(candidates, desc="Loading OME-TIFF images", unit="img") if show_progress else candidates
    for path in iterator:
        try:
            img = imread(path)
            images[path.name] = img
            break #BOORRAR ESTA LINEAAAA
        except Exception as e:
            print(f"Error loading {path.name}: {e}")
    return images


def load_dapi_masks(
    export_folder: Path = EXPORT_DAPI_FOLDER,
    show_progress: bool = True
) -> Dict[str, np.ndarray]:
    """
    Loads DAPI mask files matching DAPI_PATTERN from export_folder.
    Returns a dict mapping 'roiX' -> 2D mask array.

    Parameters:
        export_folder: Path where DAPI masks are stored.
        show_progress: If True, displays a progress bar during loading.
    """
    masks: Dict[str, np.ndarray] = {}
    base = Path(export_folder)
    tif_paths = [p for p in base.iterdir() if p.suffix.lower() == '.tif']

    iterator = tqdm(tif_paths, desc="Loading DAPI masks", unit="mask") if show_progress else tif_paths
    for path in iterator:
        m = DAPI_PATTERN.search(path.stem)
        if not m:
            print(f"Skipping file '{path.name}', does not match DAPI pattern.")
            continue
        key = f"roi{m.group(1)}_dapi"
        # Only load ROI1 for testing
        if key.lower() != 'roi1_dapi':
            continue
        try:
            masks[key] = imageio.imread(path)
        except Exception as e:
            print(f"Error loading DAPI mask {path.name}: {e}")
    return masks


def load_csv_data(
    base_path: Path,
    show_progress: bool = True
) -> Dict[str, Dict[str, pd.DataFrame]]:
    """
    Recursively loads all CSV files under base_path
    into a nested dict {subfolder: {filename: DataFrame}}.

    Parameters:
        base_path: Root directory to search for CSVs.
        show_progress: If True, displays a progress bar during loading.
    """
    result: Dict[str, Dict[str, pd.DataFrame]] = {}
    base = Path(base_path)
    subdirs = [d for d in base.iterdir() if d.is_dir()]

    dir_iter = tqdm(subdirs, desc="Loading CSV subfolders", unit="dir") if show_progress else subdirs
    for subdir in dir_iter:
        files_dict: Dict[str, pd.DataFrame] = {}
        csv_files = list(subdir.glob(f"*{CSV_EXTENSION}"))
        file_iter = tqdm(csv_files, desc=f"Reading CSVs in {subdir.name}", unit="file") if show_progress else csv_files
        for file in file_iter:
            try:
                df = pd.read_csv(file)
                files_dict[file.name] = df
            except Exception as e:
                print(f"Error reading CSV {file}: {e}")
        result[subdir.name] = files_dict
    return result



import os
import pandas as pd

def load_distance_matrices(base_path):
    dic_distancias = {}
    for group in os.listdir(base_path):  # "A_neg", "A_pos"
        path_group = os.path.join(base_path, group)
        if not os.path.isdir(path_group): continue
        files_dict = {}
        # ahora iteramos también dentro de cada sub-subcarpeta:
        for subpop in os.listdir(path_group):
            path_subpop = os.path.join(path_group, subpop)
            if not os.path.isdir(path_subpop): continue
            for fname in os.listdir(path_subpop):
                if fname.lower().endswith('.csv'):
                    full = os.path.join(path_subpop, fname)
                    files_dict[f"{subpop}/{fname}"] = pd.read_csv(full)
        dic_distancias[group] = files_dict
    return dic_distancias
--------
./io/paths.py:
--------
./io/__init__.py:
--------
./preprocessing/segmentation.py:
import os
import numpy as np
import matplotlib.pyplot as plt
import tifffile
from typing import Dict, Callable, List, Optional, Union
from multiplex_pipeline.utils.helpers import extract_roi_number
from skimage.morphology import remove_small_objects, remove_small_holes, binary_closing, disk


def post_process_mask(mask: np.ndarray, min_size: int = 0, max_hole_size: int = 10000) -> np.ndarray:
    """
    Fill small holes and remove small objects from a binary mask.
    """
    mask_bool = mask.astype(bool)
    if max_hole_size > 0:
        mask_bool = remove_small_holes(mask_bool, area_threshold=max_hole_size)
        print(f"Holes ≤ {max_hole_size} px filled.")
    if min_size > 0:
        mask_bool = remove_small_objects(mask_bool, min_size=min_size)
        print(f"Objects < {min_size} px removed.")
    return mask_bool


def post_process_mask_closing(mask: np.ndarray, min_size: int = 0, max_hole_size: int = 10000) -> np.ndarray:
    """
    Perform a large morphological closing to unify structures, ignoring size parameters.
    """
    mask_bool = mask.astype(bool)
    selem = disk(20)
    closed = binary_closing(mask_bool, selem)
    print(f"Performed closing (disk radius=20).")
    return closed


def generate_initial_mask(
    channel_data: np.ndarray,
    score: Union[Dict[str, float], float],
    scaling_divisor: float
) -> (np.ndarray, np.ndarray):
    """
    Compute initial binary mask by thresholding channel data.
    Returns the raw channel and the binary initial mask.
    """
    m, s = channel_data.mean(), channel_data.std()
    thresh = m + (score / scaling_divisor) * 3 * s
    initial_mask = channel_data > thresh
    return channel_data, initial_mask


def apply_dapi_mask(
    initial_mask: np.ndarray,
    roi_num: str,
    dapi_masks: Dict[str, np.ndarray],
    require_dapi: bool,
    name: str
) -> Optional[np.ndarray]:
    """
    If require_dapi, intersect mask with DAPI ROI mask.
    Returns None if DAPI mask is missing.
    """
    if require_dapi:
        key = f"roi{roi_num}_dapi"
        dmask = dapi_masks.get(key)
        if dmask is None:
            print(f"Skipping {name}: missing DAPI mask {key}")
            return None
        return initial_mask & (dmask > 0)
    return initial_mask


def save_mask(
    mask: np.ndarray,
    base_folder: str,
    name: str,
    roi_num: str,
    filename: str
) -> None:
    """
    Save binary mask to disk under a folder named '{name} - ROI{roi_num}'.
    """
    roi_folder = os.path.join(base_folder, f"{name} - ROI{roi_num}")
    os.makedirs(roi_folder, exist_ok=True)
    tifffile.imwrite(os.path.join(roi_folder, filename), mask.astype(np.uint8))
    print(f"Saved: {os.path.join(roi_folder, filename)}")


def display_masks(
    channel: np.ndarray,
    initial_mask: np.ndarray,
    processed_mask: np.ndarray,
    brightness_factor: Optional[float],
    mask_label: str,
    channel_index: int,
    name: str,
    min_size: int,
    max_hole_size: int
) -> None:
    """
    Plot the raw channel, initial mask, and post-processed mask side by side.
    """
    fig, axs = plt.subplots(1, 3, figsize=(18, 6))
    disp = channel * brightness_factor if brightness_factor else channel
    axs[0].imshow(np.clip(disp, 0, channel.max()), cmap='gray')
    axs[0].set_title(f'{name}: {mask_label} (ch {channel_index})'); axs[0].axis('off')
    axs[1].imshow(initial_mask, cmap='gray')
    axs[1].set_title('Initial mask'); axs[1].axis('off')
    axs[2].imshow(processed_mask, cmap='gray')
    axs[2].set_title(f'Post-processed (min={min_size}, max_hole={max_hole_size})'); axs[2].axis('off')
    plt.tight_layout()
    plt.show()


def create_channel_masks(
    images_dict: Dict[str, np.ndarray],
    dapi_masks_dict: Dict[str, np.ndarray],
    channel_index: int,
    user_scores: Union[Dict[str, float], float],
    scaling_divisor: float,
    base_folder_path: str,
    min_size: int,
    max_hole_size: int,
    mask_label: str,
    mask_filename: str,
    post_process_funcs: List[Callable[[np.ndarray, int, int], np.ndarray]],
    brightness_factor: Optional[float] = None,
    require_dapi: bool = False
) -> Dict[str, np.ndarray]:
    """
    Generate, post-process, save, and display channel masks.

    Returns a dict of 'roi{n}' -> processed mask.
    """
    out_masks: Dict[str, np.ndarray] = {}

    for name, image in images_dict.items():
        roi_num = extract_roi_number(name)
        if roi_num is None:
            print(f"Skipping {name}: cannot extract ROI number.")
            continue

        # initial mask
        chan = image[channel_index].astype(float)
        score_val = user_scores[name] if isinstance(user_scores, dict) else user_scores
        chan, initial_mask = generate_initial_mask(chan, score_val, scaling_divisor)

        # apply DAPI
        masked = apply_dapi_mask(initial_mask, roi_num, dapi_masks_dict, require_dapi, name)
        if masked is None:
            continue

        # post-process
        processed = masked.copy()
        for fn in post_process_funcs:
            processed = fn(processed, min_size=min_size, max_hole_size=max_hole_size)

        # save and record
        out_key = f"roi{roi_num}"
        out_masks[out_key] = processed
        save_mask(processed, base_folder_path, name, roi_num, mask_filename)

        # display
        display_masks(
            chan,
            masked,
            processed,
            brightness_factor,
            mask_label,
            channel_index,
            name,
            min_size,
            max_hole_size
        )

    return out_masks--------
./preprocessing/__init__.py:
--------
./README.md:
--------
./utils/helpers.py:
def extract_roi_number(filename):
    """
    Extracts the ROI number from the image name.
    Example: 'ROI1.ome.tiff' -> '1'
    """
    import re
    match = re.search(r"ROI(\d+)", filename, re.IGNORECASE)
    if match:
        return match.group(1)
    return None


def invert_dict(subpop_data):
    """
    Invierte el diccionario anidado para que la nueva llave sea el ROI.
    Retorna: {roi: {subpop: dataframe, ...}, ...}
    """
    roi_dict = {}
    for subpop, roi_data in subpop_data.items():
        for roi, df in roi_data.items():
            if roi not in roi_dict:
                roi_dict[roi] = {}
            roi_dict[roi][subpop] = df
            print(f"Invirtiendo: subpop {subpop} para ROI {roi}")
    return roi_dict
--------
./utils/logging.py:
--------
./utils/parallel.py:
--------
./utils/validation.py:

def verify_binary(mask, mask_name):
    """
    Verifies if a mask is binary (contains only 0 and 1).
    
    Parameters:
    - mask (numpy array): Mask to verify.
    - mask_name (str): Name of the mask for identification.
    """
    # Get the unique values in the mask
    import numpy as np
    unique_values = np.unique(mask)
    
    # Check if all unique values are either 0 or 1
    if set(unique_values).issubset({0, 1}):
        print(f"{mask_name} is binary.")
    else:
        print(f"{mask_name} is NOT binary. Unique values found: {unique_values}")--------
./utils/__init__.py:
--------
./visualization/overlays.py:

import random

from scipy.spatial import cKDTree, KDTree, Voronoi
from skimage.measure import regionprops, find_contours
from skimage.color import label2rgb

from shapely.geometry import Polygon as ShapelyPolygon

from matplotlib.colors import Normalize
from matplotlib import cm
from matplotlib.cm import ScalarMappable
from matplotlib.patches import Polygon, Patch
import matplotlib.patches as patches

from matplotlib.collections import PatchCollection
import matplotlib.lines as mlines

# Constantes que usas pero no defines aquí:
from multiplex_pipeline.config import PIXEL_SIZE, MASK_ALPHA

# Funciones auxiliares que también debes importar si no están en este mismo módulo:
from multiplex_pipeline.analysis.spatial import (
    compute_distances,
    get_centroids,
    compute_subpop_distances
)

from multiplex_pipeline.config import CNIO_USER
import pandas as pd 
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
import os

def parse_conditions(cond_list, col_map):
    """
    Converts strings like 'CK_mask+' into
    {'is_positive_Pan_Cytokeratin_CK_binary': 1}
    """
    parsed = {}
    for c in (cond.strip() for cond in cond_list):
        if c.endswith('+'):
            base, val = c[:-1].strip(), 1
        elif c.endswith('-'):
            base, val = c[:-1].strip(), 0
        else:
            print(f"Ignoring invalid condition '{c}'.")
            continue
        if base in col_map:
            parsed[col_map[base]] = val
        else:
            print(f"No mapping for '{c}'.")
    return parsed

def select_subpopulation(df, parsed):
    """AND‑filter dataframe with parsed condition dict."""
    if not parsed:
        return df.iloc[0:0]
    mask = pd.Series(True, index=df.index)
    for col, val in parsed.items():
        mask &= (df[col] == val) if col in df else False
    return df[mask]

def create_color_composite(img_data, mask_dicts, markers_to_plot, roi_lower, brightness_factor=1.0):
    """
    Crea una composición aditiva multicanal, asignando colores distintos a cada canal y máscara.
    
    Parámetros:
    - img_data: array de numpy con forma (num_channels, height, width)
    - mask_dicts: diccionario que contiene las máscaras disponibles (ej. {'CK_mask': ck_masks_dict, ...})
    - markers_to_plot: lista de tuplas (nombre_marcador, índice_canal o None)
    - roi_lower: string, nombre de la ROI en minúsculas
    - brightness_factor: factor de ajuste de brillo
    
    Retorna:
    - composite: array de numpy con forma (height, width, 3) representando la mezcla aditiva
    """
    height, width = img_data.shape[1], img_data.shape[2]
    composite = np.zeros((height, width, 3), dtype=np.float32)

    # Lista de colores base (Rojo, Verde, Azul, Magenta, Cian, Amarillo, etc.)
    base_colors = np.array([
        [1, 0, 0],      # Rojo
        [0, 1, 0],      # Verde
        [0, 0, 1],      # Azul
        [1, 0, 1],      # Magenta
        [0, 1, 1],      # Cian
        [1, 1, 0],      # Amarillo
        [0.5, 0.5, 0],  # Oliva
        [0.5, 0, 0.5],  # Púrpura
        [0, 0.5, 0.5],  # Teal
    ], dtype=np.float32)

    for i, (marker_name, ch) in enumerate(markers_to_plot):
        color = base_colors[i % len(base_colors)]  # Asigna color único

        if ch is not None:
            # Es un canal de intensidad
            channel_data = img_data[ch, :, :] * brightness_factor
            cmin, cmax = channel_data.min(), channel_data.max()
            if cmax == cmin:
                channel_norm = np.zeros_like(channel_data, dtype=np.float32)
            else:
                channel_norm = (channel_data - cmin) / (cmax - cmin)
            gamma = 0.5
            channel_gamma_corrected = channel_norm ** gamma

            # Suma aditiva al composite en cada canal RGB
            composite[:, :, 0] += channel_gamma_corrected * color[0]
            composite[:, :, 1] += channel_gamma_corrected * color[1]
            composite[:, :, 2] += channel_gamma_corrected * color[2]
        else:
            # Es una máscara
            mask_data = None
            if marker_name in mask_dicts and roi_lower in mask_dicts[marker_name]:
                mask_data = mask_dicts[marker_name][roi_lower]
            if mask_data is not None:
                # Asegurarse de que la máscara es binaria
                mask_binary = (mask_data > 0).astype(float)
                composite[:, :, 0] += mask_binary * color[0]
                composite[:, :, 1] += mask_binary * color[1]
                composite[:, :, 2] += mask_binary * color[2]
            else:
               
                pass

    # Limitar valores para evitar que excedan 1
    composite = np.clip(composite, 0, 1)
    return composite

def plot_conditional_cells_channels(
    rois, 
    conditions, 
    dapi_masks_dict, 
    images_dict, 
    df_binary, 
    marker_dict, 
    ck_masks_dict, 
    ngfr_masks_dict, 
    condition_column_map, 
    brightness_factor=1.0
    ):
    def is_mask_marker(name):
        return name.lower().endswith('_mask')

    def is_intensity_marker(name):
        return name.lower().endswith('_intensity')

    def get_channel_for_marker(marker_short):
        """Devuelve el índice de canal si es *_intensity; None si es *_mask."""
        if is_mask_marker(marker_short):
            return None
        base_name = marker_short.replace('_intensity', '').strip()
        for ch, full_name in marker_dict.items():
            if base_name.lower() == full_name.lower():
                print(f"Marker '{base_name}' matched with channel {ch}")
                return ch
        print(f"Channel not found for marker '{marker_short}'")
        return None

    def parse_conditions(conditions, condition_column_map):
        """Returns un dict con { binary_column: value (1 o 0), ... }"""
        parsed = {}
        for cond in conditions:
            if cond.endswith('+'):
                shorthand = cond[:-1]
                val = 1
            elif cond.endswith('-'):
                shorthand = cond[:-1]
                val = 0
            else:
                print(f"Formato de condición desconocido: {cond}. Debe terminar en '+' o '-'.")
                continue

            if shorthand in condition_column_map:
                marker_col = condition_column_map[shorthand]
                parsed[marker_col] = val
            else:
                print(f"No se encontró mapeo para la condición {shorthand}")
        return parsed

    parsed_conditions = parse_conditions(conditions, condition_column_map)

    # Preparamos la lista de marcadores (tuplas) a mostrar
    markers_to_plot = []
    mask_dicts_combined = {
        'CK_mask': ck_masks_dict,
        'NGFR_mask': ngfr_masks_dict,
    }
    for cond in conditions:
        # Por ej. cond = 'CK_mask+', 'CD3_intensity+', etc.
        shorthand = cond[:-1]  # quita el + o -
        ch = get_channel_for_marker(shorthand)
        markers_to_plot.append((shorthand, ch))

    for roi in rois:
        print(f"Processing {roi}...")
        roi_lower = roi.lower()
        roi_dapi_key = f"{roi_lower}_dapi"

        if roi_dapi_key not in dapi_masks_dict:
            print(f"Warning: {roi_dapi_key} no se encuentra en dapi_masks_dict. Saltando...")
            continue

        # Buscar la clave en images_dict que contenga el ROI
        roi_image_key = None
        for key in images_dict.keys():
            if roi_lower in key.lower():
                roi_image_key = key
                break
        if roi_image_key is None:
            print(f"No se encontró imagen en images_dict para {roi}")
            continue

        img_data = images_dict[roi_image_key]  # shape (channels, height, width)
        cell_mask = dapi_masks_dict[roi_dapi_key]
        df_roi = df_binary[df_binary['ROI'] == roi]

        # Determinar celdas que cumplen TODAS las condiciones
        condition_series = pd.Series([True]*len(df_roi), index=df_roi.index)
        for marker_col, val in parsed_conditions.items():
            condition_series &= (df_roi[marker_col] == val)

        selected_cells = df_roi[condition_series]['DAPI_ID'].tolist()
        print(f"ROI {roi}: {len(selected_cells)} celdas cumplen {conditions}")

        mask_selected = np.isin(cell_mask, selected_cells).astype(int) if selected_cells else np.zeros_like(cell_mask, dtype=int)

        n_markers = len(markers_to_plot)
        n_cols = n_markers + 2
        
        fig = plt.figure(figsize=(6*n_cols, 12))
        
        # Generar un colormap aleatorio para las células (igual que antes)
        cell_labels = np.unique(cell_mask)
        cell_labels = cell_labels[cell_labels != 0]
        num_labels = len(cell_labels) + 1
        np.random.seed(42)
        rand_colors = np.random.rand(num_labels, 3)
        rand_colors[0] = [0, 0, 0] 
        cmap_cells = ListedColormap(rand_colors)
        
        # --------------------------------------
        # Listas donde guardaremos cada imagen de la fila
        top_images = [None] * n_cols
        bottom_images = [None] * n_cols
        # --------------------------------------
        
        # ==================== FILA SUPERIOR ====================
        # (1) Columna 1 (arriba): composite multicolor
        ax_top_left = plt.subplot(2, n_cols, 1)
        composite = create_color_composite(
            img_data, 
            mask_dicts_combined, 
            markers_to_plot, 
            roi_lower, 
            brightness_factor=brightness_factor
        )
        ax_top_left.imshow(composite, interpolation='nearest')
        ax_top_left.set_title('Multicolor Composite\n(Intensity + Masks)')
        ax_top_left.axis('off')
        top_images[0] = composite  # almacenamos la composite en la posición 0
        
        # (2) Columnas 2..(n_markers+1), fila superior: canales individuales
        for i, (marker_name, ch) in enumerate(markers_to_plot, start=2):
            ax_top = plt.subplot(2, n_cols, i)
            if is_mask_marker(marker_name):
                # Plot de la máscara
                if marker_name in mask_dicts_combined and roi_lower in mask_dicts_combined[marker_name]:
                    mask_img = mask_dicts_combined[marker_name][roi_lower]
                    ax_top.imshow(mask_img, cmap='gray')
                    top_images[i-1] = mask_img.astype(float)
                else:
                    zeros_img = np.zeros_like(cell_mask, dtype=float)
                    ax_top.imshow(zeros_img, cmap='gray')
                    top_images[i-1] = zeros_img
                ax_top.set_title(f'Mask: {marker_name}')
        
            elif is_intensity_marker(marker_name):
                # Plot del canal intensidad
                if ch is not None:
                    channel_data = img_data[ch, :, :] * brightness_factor
                    cmin, cmax = channel_data.min(), channel_data.max()
                    if cmax == cmin:
                        channel_norm = np.zeros_like(channel_data)
                    else:
                        channel_norm = (channel_data - cmin) / (cmax - cmin)
                    gamma = 0.5
                    channel_gamma_corrected = channel_norm ** gamma
                    ax_top.imshow(channel_gamma_corrected, cmap='gray')
                    top_images[i-1] = channel_gamma_corrected
                else:
                    zeros_img = np.zeros_like(cell_mask, dtype=float)
                    ax_top.imshow(zeros_img, cmap='gray')
                    top_images[i-1] = zeros_img
                ax_top.set_title(f'Intensity: {marker_name}')
            else:
                # Caso no manejado
                zeros_img = np.zeros_like(cell_mask, dtype=float)
                ax_top.imshow(zeros_img, cmap='gray')
                top_images[i-1] = zeros_img
                ax_top.set_title(f'?? {marker_name}')
        
            ax_top.axis('off')
        
        # (3) Columna n_markers+2, fila superior: AQUI HACEMOS LA MEDIA
        ax_top_right = plt.subplot(2, n_cols, n_markers + 2)
        # Calculamos la media de las imágenes de las columnas 2..(n_markers+1),
        # o sea, indices 1..n_markers en top_images (excluimos la 0, que es el composite).
        imgs_for_average_top = [top_images[idx] for idx in range(1, n_markers+1)]
        # Verificamos que sean 2D todas (en caso de que alguna fuera RGB, puede requerir adaptación).
        avg_top = np.mean(imgs_for_average_top, axis=0)
        
        ax_top_right.imshow(avg_top, cmap='gray')
        ax_top_right.set_title('Media (Fila Superior)')
        ax_top_right.axis('off')
        top_images[n_markers+1] = avg_top  # Guardamos la imagen final por si se usa después
        
        # ==================== FILA INFERIOR ====================
        # (4) Columna 1 (abajo): composite + TODAS las células
        ax_bottom_left = plt.subplot(2, n_cols, n_cols + 1)
        composite_2x = np.clip(top_images[0] * 2, 0, 1)  # duplicamos brillo de la composite
        ax_bottom_left.imshow(composite_2x, interpolation='nearest') 
        ax_bottom_left.imshow(cell_mask, cmap=cmap_cells, alpha=0.5, interpolation='nearest')
        ax_bottom_left.set_title('All Cells (sobre Composite)')
        ax_bottom_left.axis('off')
        bottom_images[0] = composite_2x
        
        # (5) Columnas 2..(n_markers+1) (abajo): el mismo canal/máscara, pero con brillo x2
        for j, (marker_name, _) in enumerate(markers_to_plot, start=2):
            ax_bottom = plt.subplot(2, n_cols, n_cols + j)
            fondo = top_images[j-1]  # la imagen que habíamos guardado arriba
            fondo_2x = np.clip(fondo * 2, 0, 1)  # duplicamos brillo
            bottom_images[j-1] = fondo_2x  # guardamos esta versión en la lista bottom_images
        
            ax_bottom.imshow(fondo_2x, cmap='gray')
            # Overlay: celdas positivas para el marcador
            col_bin = condition_column_map.get(marker_name)
            if col_bin is not None:
                # Aquí consultamos si hay un valor (0 o 1) definido para este marcador en parsed_conditions
                val = parsed_conditions.get(col_bin, None)
                if val is not None:
                    # Muestra celdas == val (si val = 1 → positivas, si val = 0 → negativas)
                    selected_cells_for_marker = df_roi[df_roi[col_bin] == val]['DAPI_ID'].tolist()
                else:
                    # Si el marcador no está en las condiciones, decide por defecto (por ej. siempre 1)
                    selected_cells_for_marker = df_roi[df_roi[col_bin] == 1]['DAPI_ID'].tolist()
            else:
                selected_cells_for_marker = []
            
            mask_positive = np.isin(cell_mask, selected_cells_for_marker).astype(int)
            ax_bottom.imshow(mask_positive * cell_mask, cmap=cmap_cells, interpolation='nearest', alpha=0.5)

        
            ax_bottom.imshow(mask_positive * cell_mask, cmap=cmap_cells, interpolation='nearest', alpha=0.5)
            ax_bottom.set_title(f'Pos Cells\n{marker_name}')
            ax_bottom.axis('off')
        
        # (6) Columna n_markers+2, fila inferior: AQUI TAMBIÉN HACEMOS LA MEDIA
        ax_bottom_right = plt.subplot(2, n_cols, 2*n_cols)
        # Calculamos la media de las columnas 2..(n_markers+1) en la fila inferior,
        # que son indices 1..n_markers en bottom_images (excluyendo el 0 que es composite_2x).
        imgs_for_average_bottom = [bottom_images[idx] for idx in range(1, n_markers+1)]
        avg_bottom = np.mean(imgs_for_average_bottom, axis=0)
        # Mostramos esa media (si quieres aplicarle x2 adicional, podrías hacerlo, pero aquí ya está “iluminada”).
        ax_bottom_right.imshow(avg_bottom, cmap='gray')  
        
        if selected_cells:
            # Celdas finales
            cmap_selected = ListedColormap(['black'] + [np.random.rand(3,) for _ in range(len(selected_cells))])
            ax_bottom_right.imshow(mask_selected * cell_mask, cmap=cmap_selected, interpolation='nearest', alpha=0.7)
            ax_bottom_right.set_title(f'Final Filter:\n{conditions}')
        else:
            ax_bottom_right.imshow(mask_selected, cmap='gray', alpha=0.7, interpolation='nearest')
            ax_bottom_right.set_title(f'Final Filter (0)\n{conditions}')
        
        ax_bottom_right.axis('off')
        bottom_images[n_markers+1] = avg_bottom  # por si lo necesitas más adelante
        
        plt.tight_layout()
        plt.show()
        print(f"Plot generado para {roi}.")


def create_marker_plot(
    roi, marker_mask, marker_name, marker_color,
    dapi_mask, merged_df,
    col_map, subpop_name, subpop_conditions,
    max_cells=None
    ):
    parsed = parse_conditions(subpop_conditions, col_map)
    sub_df = select_subpopulation(merged_df, parsed)
    if sub_df.empty:
        print(f"{roi} / {subpop_name}: 0 cells – skipping.")
        return None

    # KD‑trees
    pos_pts = np.column_stack(np.where(marker_mask == 1))
    neg_pts = np.column_stack(np.where(marker_mask == 0))
    tree_pos = cKDTree(pos_pts) if len(pos_pts) else None
    tree_neg = cKDTree(neg_pts) if len(neg_pts) else None

    if marker_name == 'CK':
        bin_col = 'is_positive_Pan_Cytokeratin_CK_binary'
        dist_col, row_col, col_col = (
            'distance_ck_mask', 'nearest_ck_row', 'nearest_ck_col')
    else:
        bin_col = 'is_positive_NGFR_binary'
        dist_col, row_col, col_col = (
            'distance_ngfr_mask', 'nearest_ngfr_row', 'nearest_ngfr_col')

    dists, near_pts = [], []
    for _, r in sub_df.iterrows():
        centroid = (r['centroid_row'], r['centroid_col'])
        if r[bin_col] == 0:
            dist, idx = tree_pos.query(centroid) if tree_pos else (0.0, 0)
            near  = tuple(map(int, tree_pos.data[idx])) if tree_pos else centroid
        else:
            dist, idx = tree_neg.query(centroid) if tree_neg else (0.0, 0)
            near  = tuple(map(int, tree_neg.data[idx])) if tree_neg else centroid
        dists.append(dist * PIXEL_SIZE)
        near_pts.append(near)

    sub_df = sub_df.copy()
    sub_df[dist_col] = dists
    sub_df[row_col]  = [p[0] for p in near_pts]
    sub_df[col_col]  = [p[1] for p in near_pts]

    # keep only cells with a non‑zero distance (=> a dashed line will be drawn)
    sub_df = sub_df[sub_df[dist_col] > 0]
    if sub_df.empty:
        print(f"{roi}/{subpop_name}: all distances are 0 – nothing to show.")
        return None

    # optional sampling
    if max_cells and max_cells < len(sub_df):
        plot_df = sub_df.sample(max_cells, random_state=42)
    else:
        plot_df = sub_df

    # ------------ FIGURE ------------
    fig, ax = plt.subplots(figsize=(12, 12))
    dapi_rgb = label2rgb(dapi_mask, bg_label=0, alpha=MASK_ALPHA,
                         colors=['lightgrey'])
    ax.imshow(dapi_rgb)

    cmap = 'Reds' if marker_name == 'CK' else 'Blues'
    ax.imshow(marker_mask, cmap=cmap, alpha=MASK_ALPHA)

    for contour in find_contours(marker_mask, .5):
        ax.plot(contour[:, 1], contour[:, 0], color=marker_color, lw=1)

    ax.scatter(plot_df['centroid_col'], plot_df['centroid_row'],
               c='yellow', s=30, edgecolors='black', label=subpop_name)

    for _, r in plot_df.iterrows():
        cent = (r['centroid_col'], r['centroid_row'])
        near = (r[col_col],       r[row_col])
        line_color = marker_color if r[bin_col] == 0 else 'green'
        ax.plot([cent[0], near[0]], [cent[1], near[1]],
                color=line_color, ls='--', lw=1.5)

    # ----------- LEGEND -------------
    legend_handles = [
        patches.Patch(color=marker_color, alpha=MASK_ALPHA,
                      label=f'{marker_name} Mask'),
        mlines.Line2D([], [], color=marker_color, lw=2,
                      label=f'{marker_name} Boundary'),
        mlines.Line2D([], [], color='yellow', marker='o',
                      markeredgecolor='black', markersize=6,
                      lw=0, label=subpop_name),
        mlines.Line2D([], [], color=marker_color, ls='--', lw=2,
                      label='Marker‑ (red) → Mask'),
        mlines.Line2D([], [], color='green', ls='--', lw=2,
                      label='Marker+ (green) → Stroma')
    ]
    ax.legend(handles=legend_handles, loc='upper right')

    ax.set_title(f'ROI {roi} • {subpop_name} vs {marker_name}')
    ax.axis('off')
    fig.tight_layout()
    return fig


def plot_roi_split_markers(
    roi, dapi_masks, ck_masks, ngfr_masks,
    df_bin, col_map,
    subpop_name, subpop_conditions,
    max_cells=None
    ):
    dapi = dapi_masks.get(f"{roi}_dapi")
    if dapi is None:
        print(f"No DAPI for {roi}");  return None, None

    ck   = ck_masks.get(roi,   np.zeros_like(dapi, dtype=np.uint8))
    ngfr = ngfr_masks.get(roi, np.zeros_like(dapi, dtype=np.uint8))

    props = regionprops(dapi)
    if not props:
        print(f"No cells in {roi}");  return None, None

    centroids = [{'id_celula': p.label,
                  'centroid_row': int(p.centroid[0]),
                  'centroid_col': int(p.centroid[1])} for p in props]
    cent_df = pd.DataFrame(centroids)

    merged = pd.merge(cent_df, df_bin,
                      left_on='id_celula', right_on='DAPI_ID', how='left')
    merged['is_positive_Pan_Cytokeratin_CK_binary'] = \
        merged['is_positive_Pan_Cytokeratin_CK_binary'].fillna(0).astype(int)
    merged['is_positive_NGFR_binary'] = \
        merged['is_positive_NGFR_binary'].fillna(0).astype(int)

    fig_ck   = create_marker_plot(
        roi, ck, 'CK', 'red', dapi, merged,
        col_map, subpop_name, subpop_conditions, max_cells)
    fig_ngfr = create_marker_plot(
        roi, ngfr, 'NGFR', 'blue', dapi, merged,
        col_map, subpop_name, subpop_conditions, max_cells)
    return fig_ck, fig_ngfr


def compute_and_save(
    roi, subpop_name, subpop_conditions,
    path_save,
    dapi_masks, ck_masks, ngfr_masks,
    df_bin, col_map,
    max_cells=None
    ):
    out_dir = os.path.join(path_save, subpop_name)
    os.makedirs(out_dir, exist_ok=True)

    fig_ck, fig_ngfr = plot_roi_split_markers(
        roi, dapi_masks, ck_masks, ngfr_masks,
        df_bin, col_map, subpop_name, subpop_conditions,
        max_cells)

    if fig_ck is None and fig_ngfr is None:
        print(f"{roi}: {subpop_name} – no figures (distance 0 everywhere)")
        return

    if fig_ck:
        fig_ck.savefig(os.path.join(out_dir, f"roi_{roi}_ck.svg"))
        display(fig_ck)
    if fig_ngfr:
        fig_ngfr.savefig(os.path.join(out_dir, f"roi_{roi}_ngfr.svg"))
        display(fig_ngfr)

    # ---------- DISTANCE TABLE ----------
    dapi = dapi_masks.get(f"{roi}_dapi")
    ck   = ck_masks.get(roi,   np.zeros_like(dapi, dtype=np.uint8))
    ngfr = ngfr_masks.get(roi, np.zeros_like(dapi, dtype=np.uint8))

    props = regionprops(dapi)
    centroids = [{'cell_id': p.label,
                  'centroid_row': int(p.centroid[0]),
                  'centroid_col': int(p.centroid[1])} for p in props]
    cent_df = pd.DataFrame(centroids)

    merged = pd.merge(cent_df, df_bin,
                      left_on='cell_id', right_on='DAPI_ID', how='left')
    merged['is_positive_Pan_Cytokeratin_CK_binary'] = \
        merged['is_positive_Pan_Cytokeratin_CK_binary'].fillna(0).astype(int)
    merged['is_positive_NGFR_binary'] = \
        merged['is_positive_NGFR_binary'].fillna(0).astype(int)

    parsed = parse_conditions(subpop_conditions, col_map)
    sub_df = select_subpopulation(merged, parsed)

    ck_pos, ck_neg = compute_distances(
        sub_df, ck, 'is_positive_Pan_Cytokeratin_CK_binary')
    ng_pos, ng_neg = compute_distances(
        sub_df, ngfr, 'is_positive_NGFR_binary')

    sub_df = sub_df.copy()
    sub_df['distance_ck_positive']   = ck_pos
    sub_df['distance_ck_negative']   = ck_neg
    sub_df['distance_ngfr_positive'] = ng_pos
    sub_df['distance_ngfr_negative'] = ng_neg

    dist_tbl = sub_df[[
        'cell_id', 'centroid_row', 'centroid_col',
        'distance_ck_positive', 'distance_ck_negative',
        'distance_ngfr_positive', 'distance_ngfr_negative'
    ]].copy()
    dist_tbl.insert(0, 'ROI', roi)

    keep = (
        (dist_tbl['distance_ck_positive']   > 0) |
        (dist_tbl['distance_ck_negative']   > 0) |
        (dist_tbl['distance_ngfr_positive'] > 0) |
        (dist_tbl['distance_ngfr_negative'] > 0)
    )
    dist_tbl = dist_tbl[keep]

    if dist_tbl.empty:
        print(f"{roi}: {subpop_name} – CSV empty (distance 0 everywhere)")
        return

    csv_path = os.path.join(out_dir, f"roi_{roi}_distance_table.csv")
    dist_tbl.to_csv(csv_path, index=False)
    print(f"✔  CSV saved → {csv_path}")


def _reorder_masks(masks_to_shade):
    """
    Ensures CK_mask is drawn first, and everything else later.
    """
    def priority(mask_name):
        if mask_name == "CK_mask":
            return 0
        else:
            return 1
    return sorted(masks_to_shade, key=priority)

def shade_selected_masks(ax, roi, masks_to_shade, shading_dict, alpha=0.25):
    """
    Overlays multiple masks as translucent colored areas on the current axes.
    Returns a list of Patch handles for the legend.
    """
    legend_handles = []
    ordered_masks = _reorder_masks(masks_to_shade)

    for mask_name in ordered_masks:
        if mask_name not in shading_dict:
            continue
        mask_dict, color = shading_dict[mask_name]
        if roi in mask_dict:
            mask_data = mask_dict[roi]
            # Create a custom colormap with two entries: transparent and 'color'
            custom_cmap = ListedColormap([(0, 0, 0, 0), color + (1.0,)])
            ax.imshow(mask_data, cmap=custom_cmap, alpha=alpha)

            # Dummy patch for the legend
            patch = Patch(facecolor=color, alpha=alpha, label=mask_name)
            legend_handles.append(patch)

    return legend_handles

def voronoi_finite_polygons_2d(vor, radius=None):
    """
    Reconstruct finite Voronoi polygons in 2D.
    """
    if vor.points.shape[1] != 2:
        raise ValueError("Requires 2D input")

    new_regions = []
    new_vertices = vor.vertices.tolist()

    center = vor.points.mean(axis=0)
    if radius is None:
        radius = vor.points.ptp().max()*2

    # Map ridge vertices to ridges
    all_ridges = {}
    for (p1, p2), (v1, v2) in zip(vor.ridge_points, vor.ridge_vertices):
        all_ridges.setdefault(p1, []).append((p2, v1, v2))
        all_ridges.setdefault(p2, []).append((p1, v1, v2))

    # Reconstruct infinite regions
    for p1, region in enumerate(vor.point_region):
        vertices = vor.regions[region]
        if all(v >= 0 for v in vertices):
            # Finite region
            new_regions.append(vertices)
            continue

        # Infinite region
        ridges = all_ridges[p1]
        new_region = [v for v in vertices if v >= 0]

        for p2, v1, v2 in ridges:
            if v2 < 0:
                v1, v2 = v2, v1
            if v1 >= 0:
                # Already handled finite ridge
                continue

            # Compute the missing endpoint
            t = vor.points[p2] - vor.points[p1]  # Tangent
            t /= np.linalg.norm(t)
            n = np.array([-t[1], t[0]])  # Normal

            midpoint = vor.points[[p1, p2]].mean(axis=0)
            direction = np.sign(np.dot(midpoint - center, n)) * n
            far_point = vor.vertices[v2] + direction * radius

            new_vertices.append(far_point.tolist())
            new_region.append(len(new_vertices) - 1)

        # Sort region counterclockwise
        vs = np.array([new_vertices[v] for v in new_region])
        c = vs.mean(axis=0)
        angles = np.arctan2(vs[:,1] - c[1], vs[:,0] - c[0])
        new_region = np.array(new_region)[np.argsort(angles)].tolist()

        new_regions.append(new_region)

    return new_regions, np.array(new_vertices)

def plot_subpopulations_and_distances(
    roi,
    dapi_mask,
    subpopA_df,
    subpopB_df,
    dist_df,
    subpopA_name,
    subpopB_name,
    masks_to_shade=None,
    shading_dict=None,
    pixel_size=0.17,
    max_pairs=None,
    plot_type="line",
    save_plot=False,         # New parameter to control plot saving
    plot_filename=None        # New parameter for the plot filename
):
    """
    Plots subpopulations and their distances within a ROI using either lines or Voronoi diagrams.

    Parameters
    ----------
    roi : str
        Region of Interest identifier.
    dapi_mask : ndarray
        Labeled DAPI mask for the ROI.
    subpopA_df : DataFrame
        DataFrame containing cells of subpopulation A with centroids.
    subpopB_df : DataFrame
        DataFrame containing cells of subpopulation B with centroids.
    dist_df : DataFrame
        DataFrame containing pairwise distances between subpop A and B cells.
    subpopA_name : str
        Name of subpopulation A.
    subpopB_name : str
        Name of subpopulation B.
    masks_to_shade : list of str, optional
        List of mask names to overlay on the plot.
    shading_dict : dict, optional
        Dictionary mapping mask names to their data and colors.
    pixel_size : float, optional
        Size of a pixel in micrometers.
    max_pairs : int, optional
        Maximum number of pairs to plot. If None, all pairs are plotted.
    plot_type : str, optional
        Type of visualization: "line" or "voronoi".
    save_plot : bool, optional
        Whether to save the plot as an SVG file.
    plot_filename : str, optional
        The filename (including path) to save the plot.
    """
    unique_labels = np.unique(dapi_mask)
    unique_labels = unique_labels[unique_labels != 0]
    random.seed(42)
    colors = np.random.rand(len(unique_labels)+1, 3)
    colors[0] = [0, 0, 0]  # background = black
    cmap_cells = ListedColormap(colors)

    fig, ax = plt.subplots(figsize=(10,10))
    ax.imshow(dapi_mask, cmap=cmap_cells, alpha=0.4, zorder=0)

    # Optional: shading
    shading_handles = []
    if masks_to_shade and shading_dict:
        shading_handles = shade_selected_masks(ax, roi, masks_to_shade, shading_dict, alpha=0.25)

    if plot_type == "line":
        # Calculate minimum distances
        min_distA2B = dist_df.loc[dist_df.groupby('A_cell_id')['distance_px'].idxmin()]
        min_distB2A = dist_df.loc[dist_df.groupby('B_cell_id')['distance_px'].idxmin()]

        # Configure colormap for A->B lines
        if not min_distA2B.empty:
            distances = min_distA2B['distance_px']
            norm = Normalize(vmin=distances.min(), vmax=distances.max())
            cmap = cm.get_cmap('hot')  # Changed to 'hot' for yellow-red color scheme
            sm = ScalarMappable(norm=norm, cmap=cmap)
            sm.set_array([])  # Necessary for colorbar

        # 1) Subpopulation A (blue points) - zorder=1
        ax.scatter(
            subpopA_df['centroid_col'],
            subpopA_df['centroid_row'],
            s=20, c='darkblue',
            label=subpopA_name,
            zorder=1,
            alpha=0.5
        )

        # 2) Lines A->B (color based on distance) - zorder=2
        if max_pairs is not None:
            min_distA2B = min_distA2B.sample(min(len(min_distA2B), max_pairs), random_state=42)
        for _, row in min_distA2B.iterrows():
            a_col, a_row = row['A_col'], row['A_row']
            b_col, b_row = row['B_col'], row['B_row']
            distance = row['distance_px']
            color = cmap(norm(distance))  # Get color based on distance
            ax.plot([a_col, b_col], [a_row, b_row],
                    color=color, linewidth=1, alpha=0.8, zorder=2)

        # 3) Subpopulation B (green points) - zorder=3
        ax.scatter(
            subpopB_df['centroid_col'],
            subpopB_df['centroid_row'],
            s=20, c='darkgreen',
            label=subpopB_name,
            zorder=3
        )

        # 4) Lines B->A (light green) - zorder=4
        if max_pairs is not None:
            min_distB2A = min_distB2A.sample(min(len(min_distB2A), max_pairs), random_state=42)
        for _, row in min_distB2A.iterrows():
            b_col, b_row = row['B_col'], row['B_row']
            a_col, a_row = row['A_col'], row['A_row']
            ax.plot([b_col, a_col], [b_row, a_row],
                    c='lightgreen', linewidth=2, alpha=0.8, zorder=4)

        ax.set_title(f"ROI: {roi} - Distances from '{subpopB_name}' to '{subpopA_name}'")

        # Finalize legend
        existing_handles, existing_labels = ax.get_legend_handles_labels()
        final_handles = existing_handles + shading_handles
        final_labels = existing_labels + [h.get_label() for h in shading_handles]
        ax.legend(final_handles, final_labels, loc='best')

        # Add colorbar for distances
        if not min_distA2B.empty:
            cbar = fig.colorbar(sm, ax=ax, fraction=0.046, pad=0.04)
            cbar.set_label('Distance (px)')

    elif plot_type == "voronoi":
        # Determine which subpopulation is smaller
        if len(subpopA_df) <= len(subpopB_df):
            seeds_df = subpopA_df.copy()
            points_df = subpopB_df.copy()
            seeds_name = subpopA_name
            points_name = subpopB_name
            seed_id = 'A_cell_id'
            point_id = 'B_cell_id'
        else:
            seeds_df = subpopB_df.copy()
            points_df = subpopA_df.copy()
            seeds_name = subpopB_name
            points_name = subpopA_name
            seed_id = 'B_cell_id'
            point_id = 'A_cell_id'

        # Extract seed points
        seed_points = seeds_df[['centroid_col', 'centroid_row']].values

        # Handle case with fewer than 1 seed point
        if len(seed_points) < 1:
            print(f"Not enough seed points for Voronoi diagram in ROI {roi}. Skipping Voronoi visualization.")
            return

        # Create KDTree for efficient nearest neighbor search
        tree = KDTree(seed_points)

        # Extract coordinates of subpopulation B cells
        point_coords = points_df[['centroid_col', 'centroid_row']].values

        # Query nearest seed for each point
        distances, indices = tree.query(point_coords, k=1)

        # Assign nearest seed index to each point
        points_df['nearest_seed_idx'] = indices.flatten()
        points_df['distance_px'] = distances.flatten()

        # Get coordinates of nearest seeds for each point
        nearest_seeds = seed_points[points_df['nearest_seed_idx'].values]
        points_df['seed_col'] = nearest_seeds[:, 0]
        points_df['seed_row'] = nearest_seeds[:, 1]

        # Normalize distances for colormap
        norm = Normalize(vmin=points_df['distance_px'].min(), vmax=points_df['distance_px'].max())
        cmap = cm.get_cmap('hot')  # From red to yellow
        sm = ScalarMappable(norm=norm, cmap=cmap)
        sm.set_array([])  # Necessary for colorbar

        # Plot Voronoi polygons (optional)
        try:
            vor = Voronoi(seed_points)
            regions, vertices = voronoi_finite_polygons_2d(vor)

            # Define plot boundaries
            min_x = 0
            max_x = dapi_mask.shape[1]
            min_y = 0
            max_y = dapi_mask.shape[0]
            bounding_polygon = ShapelyPolygon([
                (min_x, min_y),
                (min_x, max_y),
                (max_x, max_y),
                (max_x, min_y)
            ])

            # Assign unique color to each Voronoi region
            num_regions = len(regions)
            vor_colors = cm.tab20(np.linspace(0, 1, num_regions))

            patches = []
            colors_voronoi = []
            for region_idx, region in enumerate(regions):
                polygon = vertices[region]
                shapely_poly = ShapelyPolygon(polygon)
                # Clip polygon to plot boundaries
                shapely_poly = shapely_poly.intersection(bounding_polygon)
                if not shapely_poly.is_empty:
                    if isinstance(shapely_poly, ShapelyPolygon):
                        patches.append(Polygon(np.array(shapely_poly.exterior.coords)))
                        colors_voronoi.append(vor_colors[region_idx % len(vor_colors)])
                    elif isinstance(shapely_poly, (list, np.ndarray)):
                        for poly in shapely_poly:
                            patches.append(Polygon(np.array(poly.exterior.coords)))
                            colors_voronoi.append(vor_colors[region_idx % len(vor_colors)])
            # Create a collection of patches
            p = PatchCollection(patches, facecolor=colors_voronoi, edgecolor='k', alpha=0.3, zorder=1)
            ax.add_collection(p)
        except Exception as e:
            print(f"Error generating Voronoi diagram: {e}")

        # Plot subpopulation B points colored by distance
        sc = ax.scatter(
            points_df['centroid_col'],
            points_df['centroid_row'],
            c=points_df['distance_px'],
            cmap=cmap,
            s=20,
            label=f"{points_name} (colored by distance)",
            zorder=3,
            alpha=0.4
        )

        # Add colorbar for heatmap
        cbar = fig.colorbar(sm, ax=ax, fraction=0.046, pad=0.04)
        cbar.set_label('Distance to Centroid (px)')

        # Plot seed points
        ax.scatter(
            seeds_df['centroid_col'],
            seeds_df['centroid_row'],
            s=40,
            c='green',
            marker='o',
            label=f"{seeds_name}",
            zorder=4
        )

        ax.set_title(f"ROI: {roi} - Voronoi Diagram between '{seeds_name}' and '{points_name}'")

        # Finalize legend
        existing_handles, existing_labels = ax.get_legend_handles_labels()
        final_handles = existing_handles + shading_handles
        final_labels = existing_labels + [h.get_label() for h in shading_handles]
        ax.legend(final_handles, final_labels, loc='best')

    else:
        print(f"Unknown plot_type '{plot_type}'. Supported types are 'line' and 'voronoi'.")

    ax.set_axis_off()

    # Save the plot as SVG if required
    if save_plot and plot_filename:
        # Ensure the directory exists
        plot_dir = os.path.dirname(plot_filename)
        if not os.path.exists(plot_dir):
            os.makedirs(plot_dir)
        # Save the figure
        plt.savefig(plot_filename, format='svg', bbox_inches='tight')
        print(f"Plot saved as SVG: {plot_filename}")

    plt.show()

import os
from multiplex_pipeline.config import (
    DISTANCES_POPULATIONS_DIR,
    SUBPOPULATION_A_POSITIVE,
    SUBPOPULATION_A_NEGATIVE,
    SUBPOPULATIONS,
    CONDITION_COLUMN_MAP,
    SHADING_COLORS,
    PIXEL_SIZE,
    ROIS_TO_ANALYZE
)

# Ruta de guardado ajustada para evitar la creación de carpetas padre
def compute_and_plot_subpop_distances_for_all_rois(
    rois,
    subpop_conditions_A,
    subpop_conditions_B,
    df_binary,
    dapi_masks_dict,
    condition_column_map,
    pixel_size=0.17,
    max_pairs=None,
    masks_to_shade=None,
    shading_dict=None,
    save_matrix_as_csv=False,
    path_save="..\\results_spatial_analysis\\" + CNIO_USER + "\\distances_between_populations",
    print_pivot_head=False,
    plot_type="line",
    subpopB_label=None  # Parámetro opcional
):
    """
    Para cada ROI en 'rois':
      1) Parsea las condiciones de subpoblación A y B.
      2) Encuentra las celdas de A y B dentro de ese ROI.
      3) Calcula todas las distancias entre cada celda de A y cada celda de B.
      4) Crea una tabla dinámica (filas = celdas de A, columnas = celdas de B).
      5) Imprime opcionalmente las primeras 10 filas de la tabla dinámica.
      6) Guarda opcionalmente la tabla dinámica como CSV.
      7) Grafica cada ROI, sombreando las máscaras seleccionadas y mostrando las subpoblaciones más líneas
         (A->B y B->A) o diagramas de Voronoi según el tipo de gráfico especificado.
    """

    # Define el nombre de la subpoblación de A y B
    subpopA_name = "_".join(subpop_conditions_A)  # Aquí usamos un solo nombre simplificado
    subpopB_name = subpopB_label if subpopB_label is not None else "_".join(subpop_conditions_B)  # De igual manera para B
    
    # Parseamos las condiciones
    parsedA = parse_conditions(subpop_conditions_A, condition_column_map)
    parsedB = parse_conditions(subpop_conditions_B, condition_column_map)

    all_distances = {}

    for roi in rois:
        print(f"\n=== ROI {roi} ===")
        dapi_key = roi.lower() + "_dapi"
        if dapi_key not in dapi_masks_dict:
            print(f"Missing DAPI mask for {dapi_key}. Skipping.")
            continue

        # Extraemos la máscara de DAPI etiquetada
        dapi_mask = dapi_masks_dict[dapi_key]

        # Filtramos df_binary para este ROI
        df_roi = df_binary[df_binary['ROI'] == roi].copy()

        # Fusionamos con los centroides
        centroids_df = get_centroids(dapi_mask)
        df_roi = pd.merge(df_roi, centroids_df, on='DAPI_ID', how='left')

        # Seleccionamos las subpoblaciones
        subpopA = select_subpopulation(df_roi, parsedA)
        subpopB = select_subpopulation(df_roi, parsedB)

        # Calculamos todas las distancias
        dist_df = compute_subpop_distances(subpopA, subpopB)
        if dist_df.empty:
            print(f"No distances to compute for {roi} (subpopulation A or B is empty).")
            all_distances[roi] = dist_df
            continue  # Saltamos al siguiente ROI      
        dist_df['ROI'] = roi
        dist_df['distance_um'] = dist_df['distance_px'] * pixel_size

        all_distances[roi] = dist_df

        # Creamos la tabla dinámica
        dist_df['A_roi_cell'] = dist_df['ROI'].astype(str) + "_" + dist_df['A_cell_id'].astype(str)
        dist_df['B_roi_cell'] = dist_df['ROI'].astype(str) + "_" + dist_df['B_cell_id'].astype(str)

        distance_matrix = dist_df.pivot(
            index='A_roi_cell',
            columns='B_roi_cell',
            values='distance_um'
        )

        print(f"rows: {subpopA_name}")
        print(f"columns: {subpopB_name}")
        if print_pivot_head:
            print(distance_matrix.head(10))

        if save_matrix_as_csv:
            # Ruta de guardado con subpoblación A y B combinadas sin subdirectorios innecesarios
            csv_filename = f"distance_matrix_{roi}_{subpopA_name}_vs_{subpopB_name}.csv"
            csv_filepath = os.path.join(path_save, csv_filename)  # Guardar en una única carpeta combinada
            distance_matrix.to_csv(csv_filepath, index=True)
            print(f"Matrix saved as CSV: {csv_filepath}")

        # Graficar solo si ambas subpoblaciones tienen celdas
        if len(subpopA) > 0 and len(subpopB) > 0:
            # Definir la ruta para el gráfico (formato SVG)
            plot_filename = os.path.join(
                path_save,
                f"plot_{roi}_{subpopA_name}_vs_{subpopB_name}.svg"
            )
            
            plot_subpopulations_and_distances(
                roi=roi,
                dapi_mask=dapi_mask,
                subpopA_df=subpopA,
                subpopB_df=subpopB,
                dist_df=dist_df,
                subpopA_name=subpopA_name,
                subpopB_name=subpopB_name,
                masks_to_shade=masks_to_shade,
                shading_dict=shading_dict,
                pixel_size=pixel_size,
                max_pairs=max_pairs,
                plot_type=plot_type,  # Pasar el parámetro plot_type
                save_plot=True,       # Habilitar la opción de guardar el gráfico
                plot_filename=plot_filename  # Pasar el nombre del archivo de gráfico
            )
        else:
            print(f"One or both subpopulations are empty in {roi}. No plot.")

    return all_distances
--------
./visualization/qc.py:

import os
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from typing import Dict, Callable, List, Tuple
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter
import matplotlib.patches as mpatches
import re

def plot_masks(dapi_masks_dict):
    import numpy as np 
    from matplotlib.colors import ListedColormap
    import matplotlib.pyplot as plt 

    for extracted_name, mask in dapi_masks_dict.items():
        # Create a random color map for the labels
        unique_labels = np.unique(mask)
        num_labels = len(unique_labels)
        colors = np.random.rand(num_labels, 3)  # Generate random colors
        colors[0] = [0, 0, 0]  # Background (label 0) in black
        cmap = ListedColormap(colors)

        # Display the mask with the assigned colors
        plt.figure(figsize=(12, 12))
        plt.imshow(mask, cmap=cmap, interpolation='nearest')
        plt.title(f"Segmented Mask - {extracted_name}")
        plt.colorbar(boundaries=np.arange(-0.5, num_labels, 1), ticks=np.linspace(0, num_labels - 1, min(20, num_labels), dtype=int))
        plt.xlabel("X (px)")
        plt.ylabel("Y (px)")
        plt.show()

        # Print statistics
        print(f"Number of unique labels in {extracted_name} (excluding background): {num_labels - 1}")

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter
import matplotlib.patches as mpatches

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter
import matplotlib.patches as mpatches

def generate_boxplots_nested(
    nested_data: dict[str, dict[str, pd.DataFrame]],
    positive_col: str,
    negative_col: str,
    label: str,
    output_dir: str,
    prefix: str
):
    """
    Modo: mask↔subpop: cada df tiene positive_col & negative_col → varios ROIs, dos violines+boxplots
    """
    os.makedirs(output_dir, exist_ok=True)

    for key1, subdict in nested_data.items():
        df0 = next(iter(subdict.values()))
        keys = set(subdict.keys())

        # --- MODO: mask↔subpop (múltiples ROIs) ---
        if positive_col in df0.columns and negative_col in df0.columns:
            names2 = sorted(subdict.keys())
            pos_data = []; neg_data = []
            for roi in names2:
                df = subdict[roi]
                p = df[positive_col][df[positive_col] != 0].tolist() or [np.nan]
                n = df[negative_col][df[negative_col] != 0].tolist() or [np.nan]
                if len(p) == 1: p *= 2
                if len(n) == 1: n *= 2
                pos_data.append(p); neg_data.append(n)

            fig, ax = plt.subplots(figsize=(10, 6))
            positions = np.arange(1, len(names2) + 1)
            off = 0.2
            vp1 = ax.violinplot(pos_data, positions=positions - off, widths=0.35,
                                showmeans=False, showmedians=False, showextrema=False)
            for b in vp1['bodies']:
                b.set_facecolor('lightcoral'); b.set_edgecolor('black'); b.set_alpha(0.5)
            ax.boxplot(pos_data, positions=positions - off, widths=0.15,
                       patch_artist=True, showfliers=False,
                       boxprops=dict(facecolor='white', edgecolor='black'))

            vp2 = ax.violinplot(neg_data, positions=positions + off, widths=0.35,
                                showmeans=False, showmedians=False, showextrema=False)
            for b in vp2['bodies']:
                b.set_facecolor('lightblue'); b.set_edgecolor('black'); b.set_alpha(0.5)
            ax.boxplot(neg_data, positions=positions + off, widths=0.15,
                       patch_artist=True, showfliers=False,
                       boxprops=dict(facecolor='white', edgecolor='black'))

            ax.set_xticks(positions)
            ax.set_xticklabels(names2, rotation=45, ha='right')
            patch_pos = mpatches.Patch(color='lightcoral', label=f"{label}+")
            patch_neg = mpatches.Patch(color='lightblue', label=f"{label}-")
            ax.legend(handles=[patch_pos, patch_neg], loc="best")
            title = f"{key1} ➞ {label}+ vs {label}-"

        # --- MODO 3: pivot genérico ---
        else:
            vals = []
            for df in subdict.values():
                nums = df.select_dtypes(include=[np.number]).values.flatten()
                nums = nums[nums != 0]
                if nums.size == 0: nums = np.array([np.nan])
                vals.extend(nums.tolist())
            if len(vals) == 1: vals *= 2

            fig, ax = plt.subplots(figsize=(6, 6))
            vp = ax.violinplot([vals], positions=[1], widths=0.6,
                               showmeans=False, showmedians=False, showextrema=False)
            for b in vp['bodies']:
                b.set_facecolor('skyblue'); b.set_edgecolor('black'); b.set_alpha(0.5)
            ax.boxplot([vals], positions=[1], widths=0.2,
                       patch_artist=True, showfliers=False,
                       boxprops=dict(facecolor='white', edgecolor='black'))

            ax.set_xticks([1])
            ax.set_xticklabels([key1], rotation=45, ha='right')
            ax.legend(handles=[mpatches.Patch(color='skyblue', label=label)], loc="best")
            title = f"{key1} ➞ {label} distances"

        # — Etiquetas y escala sólo si hay >0 —
        # recolectar todos los datos para este gráfico
        all_vals = []
        if positive_col in df0.columns and negative_col in df0.columns:
            all_vals = sum(pos_data + neg_data, [])
        else:
            all_vals = vals

        # filtrar NaNs
        all_vals = [v for v in all_vals if np.isfinite(v)]
        if any(v > 0 for v in all_vals):
            ax.set_yscale("log")

        ax.yaxis.set_major_formatter(FuncFormatter(lambda y, _: f"{y:.0f}"))
        ax.set_ylabel("Distance (µm)")
        ax.set_title(title, pad=15)

        fig.tight_layout(rect=[0, 0, 1, 0.92])

        # Guardar
        f = os.path.join(output_dir, f"{prefix}_{key1}.svg")
        fig.savefig(f)
        print("Guardado:", f)

        plt.show()
        plt.close(fig)

from multiplex_pipeline.config import (
    CNIO_USER, 
    RESULTS_BASE_DIR, 
    DISTANCES_POPULATIONS_DIR, 
    BOXPLOTS_DISTANCES_HEATMAPS_DIR
)

def generate_combined_boxplots(dic_distancias, save_path=BOXPLOTS_DISTANCES_HEATMAPS_DIR):
    out_dir = os.path.join(save_path)
    os.makedirs(out_dir, exist_ok=True)

    pop_dict = {}
    for _, files in dic_distancias.items():
        for fname, df in files.items():
            m = re.match(r"(distance_matrix_(roi\d+)_.*NGFR_intensity)([\+\-])(_vs.*)\.csv", fname)
            if not m:
                continue
            roi, sign = m.group(2), m.group(3)
            pop = (m.group(1).replace(f"distance_matrix_{roi}_", "") + m.group(4))
            arr = pd.to_numeric(df.values.flatten(), errors='coerce')
            arr = arr[~np.isnan(arr)]
            pop_dict.setdefault(pop, {}).setdefault(roi, {})['plus' if sign == '+' else 'minus'] = arr

    c_plus, c_minus = 'lightgreen', 'lightcoral'

    for pop, rois in pop_dict.items():
        sorted_rois = sorted(rois, key=lambda x: int(re.findall(r'\d+', x)[0]))
        fig, ax = plt.subplots(figsize=(8, 5))
        pos_plus, data_plus = [], []
        pos_minus, data_minus = [], []

        for i, roi in enumerate(sorted_rois):
            d = rois[roi]
            if 'plus' in d and 'minus' in d:
                pos_plus.append(3 * i + 1)
                data_plus.append(d['plus'])
                pos_minus.append(3 * i + 2)
                data_minus.append(d['minus'])

        # Solo procedemos si hay datos válidos en las listas
        if data_plus and data_minus:
            bp1 = ax.boxplot(data_plus, positions=pos_plus, patch_artist=True, widths=0.6, showfliers=False)
            bp2 = ax.boxplot(data_minus, positions=pos_minus, patch_artist=True, widths=0.6, showfliers=False)

            for b in bp1['boxes']:
                b.set(facecolor=c_plus, alpha=0.5)
            for b in bp2['boxes']:
                b.set(facecolor=c_minus, alpha=0.5)

            vp1 = ax.violinplot(data_plus, positions=pos_plus, widths=0.6, showextrema=False)
            vp2 = ax.violinplot(data_minus, positions=pos_minus, widths=0.6, showextrema=False)

            for v in vp1['bodies']:
                v.set_facecolor(c_plus)
                v.set_edgecolor('black')
                v.set_alpha(0.5)
            for v in vp2['bodies']:
                v.set_facecolor(c_minus)
                v.set_edgecolor('black')
                v.set_alpha(0.5)

            centers, labels = [], []
            for i, roi in enumerate(sorted_rois):
                if 'plus' in rois[roi] and 'minus' in rois[roi]:
                    centers.append((3 * i + 1 + 3 * i + 2) / 2)
                    labels.append(roi)
            ax.set_xticks(centers)
            ax.set_xticklabels(labels)
            ax.set_ylabel("Distance [µm]")
            pop_name = re.search(r'vs_(.*)', pop).group(1).replace("_", " ") if re.search(r'vs_(.*)', pop) else pop
            ax.set_title(f"Distances tumor vs {pop_name}")
            ax.legend([mpatches.Patch(facecolor=c_plus), mpatches.Patch(facecolor=c_minus)], ['NGFR+', 'NGFR−'], loc='upper right')
            
            plt.tight_layout()
            safe = re.sub(r'[^\w\-_\. ]', '_', pop_name)
            plt.savefig(os.path.join(out_dir, f"{safe}.svg"), format='svg')
            plt.show()
            plt.close(fig)
        else:
            print(f"Advertencia: No se encontraron datos válidos para la subpoblación {pop}.")
    
    # Generación de gráficos por ROI
    roi_dict = {}

    for pop, rois in pop_dict.items():
        for roi, d in rois.items():
            roi_dict.setdefault(roi, {})[pop] = d

    c_plus, c_minus = 'lightgreen', 'lightcoral'
    for roi, pops in roi_dict.items():
        sorted_pops = sorted(pops)
        fig, ax = plt.subplots(figsize=(10, 6))
        pos_plus, data_plus = [], []
        pos_minus, data_minus = [], []

        for i, pop in enumerate(sorted_pops):
            d = pops[pop]
            if 'plus' in d and 'minus' in d:
                pos_plus.append(3 * i + 1)
                pos_minus.append(3 * i + 2)
                data_plus.append(d['plus'])
                data_minus.append(d['minus'])

        # Asegurarse de que haya datos antes de procesar
        if data_plus and data_minus:
            bp1 = ax.boxplot(data_plus, positions=pos_plus, patch_artist=True, widths=0.6, showfliers=False)
            bp2 = ax.boxplot(data_minus, positions=pos_minus, patch_artist=True, widths=0.6, showfliers=False)

            for b in bp1['boxes']:
                b.set(facecolor=c_plus, alpha=0.5)
            for b in bp2['boxes']:
                b.set(facecolor=c_minus, alpha=0.5)

            vp1 = ax.violinplot(data_plus, positions=pos_plus, widths=0.6, showextrema=False)
            vp2 = ax.violinplot(data_minus, positions=pos_minus, widths=0.6, showextrema=False)

            for v in vp1['bodies']:
                v.set_facecolor(c_plus)
                v.set_edgecolor('black')
                v.set_alpha(0.5)
            for v in vp2['bodies']:
                v.set_facecolor(c_minus)
                v.set_edgecolor('black')
                v.set_alpha(0.5)
        else:
            print(f"Advertencia: No se encontraron datos válidos para el ROI {roi}.")
            continue

        centers = [(3 * i + 1 + 3 * i + 2) / 2 for i in range(len(sorted_pops))]
        ax.set_xticks(centers)
        ax.set_xticklabels([pop.replace("_", " ") for pop in sorted_pops], rotation=90, ha='center')
        ax.set_ylabel("Distance [µm]")
        ax.set_title(f"Distances for ROI {roi}")
        ax.legend([mpatches.Patch(facecolor=c_plus), mpatches.Patch(facecolor=c_minus)], ['NGFR+', 'NGFR−'], loc='upper right')
        plt.tight_layout()
        safe = re.sub(r'[^\w\-_\. ]', '_', roi)
        plt.savefig(os.path.join(out_dir, f"{safe}.svg"), format='svg')
        plt.show()
        plt.close(fig)




def plot_combination_counts(
    df: pd.DataFrame,
    rois: List[str],
    combinations: Dict[str, Callable[[pd.DataFrame], pd.Series]],
    output_dir: str,
    base_filename: str,
    plot_title: str,
    figsize: Tuple[int,int] = (20, 10),
    rotation: int = 45,
    font_scale: float = 1.0
) -> pd.DataFrame:
    """
    Filtra `df` por ROIs, cuenta para cada ROI el número de True en cada condición de `combinations`,
    guarda la tabla de counts como CSV en output_dir/{base_filename}.csv,
    genera un barplot apilado con escala log y guarda como SVG en output_dir/{base_filename}.svg,
    y retorna el DataFrame de counts.
    """
    # 1. Filtrado
    filtered = df[df['ROI'].isin(rois)]

    # 2–5. Cálculo de counts_df
    counts_df = pd.DataFrame()
    grouped = filtered.groupby('ROI')
    for name, cond in combinations.items():
        counts_df[name] = grouped.apply(lambda x: cond(x).sum())
    counts_df = counts_df.reset_index()
    counts_df['Total Cells'] = grouped.size().values

    # 6–7. Melt para plot
    counts_melted = counts_df.melt(
        id_vars=['ROI','Total Cells'],
        var_name='Combination',
        value_name='Count'
    )

    # 8–9. Directorio de salida
    os.makedirs(output_dir, exist_ok=True)

    # 10–13. Guardar CSV
    csv_path = os.path.join(output_dir, f"{base_filename}.csv")
    counts_df.to_csv(csv_path, index=False)
    print(f"Table saved as CSV at: {csv_path}")

    # 14. Plot
    plt.figure(figsize=figsize)
    sns.set_context("talk", font_scale=font_scale)
    ax = sns.barplot(
        x='ROI', y='Count', hue='Combination',
        data=counts_melted
    )
    # anotar encima de cada barra
    for p in ax.patches:
        h = p.get_height()
        if pd.notnull(h) and h > 0:
            ax.text(
                p.get_x() + p.get_width()/2,
                h + 0.1,
                f"{int(h)}",
                ha='center', va='bottom', fontsize=10, rotation=90
            )
    # total en etiquetas x
    new_lbls = [
        f"{roi}\n(Total: {tot})"
        for roi, tot in zip(counts_df['ROI'], counts_df['Total Cells'])
    ]
    ax.set_xticklabels(new_lbls, rotation=rotation)
    ax.set_yscale('log')
    ax.set_title(plot_title, fontsize=16)
    ax.set_xlabel('ROI', fontsize=14)
    ax.set_ylabel('Number of Positive Cells', fontsize=14)
    ax.legend(title='Combination', fontsize=12, title_fontsize=14)
    plt.tight_layout()

    # 15. Guardar SVG
    svg_path = os.path.join(output_dir, f"{base_filename}.svg")
    plt.savefig(svg_path, format='svg', bbox_inches='tight')
    print(f"Plot saved as SVG at: {svg_path}")

    # 16. Mostrar
    plt.show()

    return counts_df--------
./visualization/__init__.py:
--------
./__init__.py:
--------
